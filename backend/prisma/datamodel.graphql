type User {
  id: ID! @unique
  name: String # required will be handled in foxiny-gateway
  email: String @unique # required and uniqueness will be handled in foxiny-gateway
  phone: String @unique # required and uniqueness will be handled in foxiny-gateway
  password: String # required will be handled in foxiny-gateway
  emailConfirmed: Boolean @default(value: false) # determines email is confirmed or not
  phoneConfirmed: Boolean @default(value: false) # determines phone is confirmed or not
  avatar: [UserAvatar] @relation(name: "AvatarToUser", onDelete: CASCADE)
  securityAnswers: [SecurityAnswer] @relation(name: "AnswerToUser", onDelete: CASCADE) # required will be handled in foxiny-gateway
  enabled: Boolean @default(value: false) # required will be handled in foxiny-gateway
  recoverable: Boolean @default(value: false)
  createdAt: DateTime!
  updatedAt: DateTime!
}

#TODO: consider splitting User into 2 types: User and UserProfiles

type SecurityQuestion {
  id: ID! @unique
  question: String # required and uniqueness will be handled in foxiny-gateway
  securityAnswers: [SecurityAnswer] @relation(name: "AnswerToQuestion", onDelete: CASCADE)
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SecurityAnswer {
  id: ID! @unique
  user: User @relation(name: "AnswerToUser", onDelete: CASCADE) # required and uniqueness will be handled in foxiny-gateway
  securityQuestion: SecurityQuestion @relation(name: "AnswerToQuestion", onDelete: CASCADE) # required and uniqueness will be handled in foxiny-gateway
  answer: String # required and uniqueness will be handled in foxiny-gateway
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserAvatar {
  id: ID! @unique
  user: User @relation(name: "AvatarToUser", onDelete: CASCADE)
  url: String # store file name
  enabled: Boolean! @default(value: false) # determines which avatar is used
  createdAt: DateTime!
  updatedAt: DateTime!
}
